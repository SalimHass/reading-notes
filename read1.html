All growth comes with some degree of pain, as it pulls you out of your comfort zone. The greater the growth, the greater the pain. Thus pain , if it service the growth , it’s a good thing, especially that its  temporary   , but the growth gained will push you to the next phase of life.
Suffering on the other hand, is pain without purpose , without higher goal or dreams. That’s why whenever you feel the pain for the next 10 weeks remember why you are doing what you do?, and how much do you want what comes at the end of this of journey.
You should not take pain in silence, do something about it , seek remedy, ask questions and do your research, and remember that you chose this to get a better life. And after you finish this course you have Python as your tool, to use in a spectacular way .


  Big O Notation 
Is used to describe the performance or complexity of an algorithm.
O(1): means the algorithm will always take the same time and space 
O(N):the algorithm’s performance will grow linearly and in direct proportion to the size of the input data set.
O(N2): the algorithm’s performance is directly proportional to the square of the size of the input data set, and this is common with nested iterations data set.
O(2^N): the algorithm’s performance doubles with each addition to the input data set.
O(log N): it means that the performance is steadily increasing over the data set , by halving the data with each iteration , which leads to better performance over large set of data.


In the video Ned Batchelder talked about major concepts of python that a programmer might get confused while dealing with .
he started to talk about how names refers to value in an immutable type , such as int, floots , strings and tuples, and how when you try to refer
to  the name of preciously assigned name , you actually refer to the data that name pointing to . and how is that values are live until nothing is
referring to them where they will be lost inside the matrix.
He talked about how names don’t copy the data , they just point to the place where the data is stored . But if we tried to edit or add to an immutable
value where some other name refers to the same data , the one that we are assigning to only will create a new place in the memory with the name refereeing to it ,
while the other name will remain pointing to the same data place where the original data held.
He talked about how the “change” term might mean different concepts depending on the  data type mainly , for integers change means we are rebinding ,
which means we create new int and assign it to a name, while for lists , change means that we are mutating the data. It is the same data place , 
but we added something to it. And also it can mean that we are rebinding in lists , like nums=nums + [7].
He mentioned the logic behind assigning variants , where x+=y might look like x=x+y , its actually x=x._iadd_(y), the diferance here that is why is x
is controls the type.
He showed how to use return in loops to keep data in case of mutating a list , alas the data will be lost once the loop is finished . 

 
